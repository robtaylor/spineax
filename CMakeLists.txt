cmake_minimum_required(VERSION 3.15...3.27)
project(${SKBUILD_PROJECT_NAME} LANGUAGES CXX)

# Backend options
option(SPINEAX_USE_CUDA "Build with CUDA/cuDSS backend" ON)
option(SPINEAX_USE_BASPACHO "Build with BaSpaCho backend (Metal/OpenCL/CPU)" OFF)

# BaSpaCho path - set this to your baspacho installation
set(BASPACHO_ROOT "" CACHE PATH "Path to BaSpaCho installation")

# Force all CUDA libraries to be linked dynamically.
set(CMAKE_CUDA_RUNTIME_LIBRARY Shared)

# 1. Find the Python interpreter from your active environment.
find_package(Python COMPONENTS Interpreter Development REQUIRED)
message(STATUS "Using Python interpreter: ${Python_EXECUTABLE}")

# 2. Find nanobind (required for all backends)
find_package(nanobind CONFIG REQUIRED)

# 3. Find XLA FFI headers (required for all backends)
execute_process(
  COMMAND "${Python_EXECUTABLE}"
          "-c" "from jax import ffi; print(ffi.include_dir())"
  OUTPUT_STRIP_TRAILING_WHITESPACE OUTPUT_VARIABLE XLA_DIR)
message(STATUS "XLA include directory: ${XLA_DIR}")

# 4. Get the path to the CUDA libraries from the Python environment.
if(SPINEAX_USE_CUDA)
execute_process(
    COMMAND ${Python_EXECUTABLE} -c "
import sys
import os
from importlib.util import find_spec
from pathlib import Path

def get_base_path(spec):
    if spec.submodule_search_locations: return Path(spec.submodule_search_locations[0])
    return None

try:
    # Find the base path for nvidia packages
    cudnn_spec = find_spec('nvidia.cudnn')
    if cudnn_spec is None: raise ImportError('A nvidia-* pip package must be installed.')
    base_path = get_base_path(cudnn_spec)
    if base_path is None: raise ImportError('Could not determine path for nvidia packages.')
    site_packages = base_path.parent.parent
    print(f'NVIDIA_PATH={site_packages}')

    # Find CUDA Runtime
    cudart_spec = find_spec('nvidia.cuda_runtime')
    if cudart_spec is None: raise ImportError('nvidia.cuda_runtime not found.')
    cudart_path = get_base_path(cudart_spec)
    cudart_libs = list((cudart_path / 'lib').glob('libcudart.so*'))
    if not cudart_libs: raise ImportError(f'libcudart.so not found in {cudart_path}')
    cudart_lib_file = sorted(cudart_libs, key=lambda p: len(str(p)))[-1]
    print(f'CUDART_LIBRARY_PATH={cudart_lib_file.resolve()}')

    # Find cuDSS
    cudss_spec = find_spec('nvidia.cu12')
    if cudss_spec is None: raise ImportError('nvidia.cudss not found.')
    cudss_path = get_base_path(cudss_spec)
    cudss_libs = list((cudss_path / 'lib').glob('libcudss.so*'))
    if not cudss_libs: raise ImportError(f'libcudss.so not found in {cudss_path}')
    cudss_lib_file = sorted(cudss_libs, key=lambda p: len(str(p)))[-1]
    print(f'CUDSS_LIBRARY_PATH={cudss_lib_file.resolve()}')

    # Find cuBLAS
    cublas_spec = find_spec('nvidia.cublas')
    if cublas_spec is None: raise ImportError('nvidia.cublas not found. Did you pip install nvidia-cublas-cu12?')
    cublas_path = get_base_path(cublas_spec)
    cublas_libs = list((cublas_path / 'lib').glob('libcublas.so*'))
    if not cublas_libs: raise ImportError(f'libcublas.so not found in {cublas_path}')
    cublas_lib_file = sorted(cublas_libs, key=lambda p: len(str(p)))[-1]
    print(f'CUBLAS_LIBRARY_PATH={cublas_lib_file.resolve()}')

except ImportError as e:
    sys.exit(f'Could not find required packages: {e}')
"
    OUTPUT_VARIABLE PYTHON_OUTPUTS
    RESULT_VARIABLE PYTHON_RESULT
    OUTPUT_STRIP_TRAILING_WHITESPACE
)

if(PYTHON_RESULT)
    message(FATAL_ERROR "Failed to find NVIDIA packages: ${PYTHON_RESULT}")
endif()

# Parse outputs
string(REGEX MATCH "NVIDIA_PATH=([^\n]*)" _ ${PYTHON_OUTPUTS})
set(ENV_NVIDIA_PATH ${CMAKE_MATCH_1})
string(REGEX MATCH "CUDART_LIBRARY_PATH=([^\n]*)" _ ${PYTHON_OUTPUTS})
set(ENV_CUDART_PATH ${CMAKE_MATCH_1})
string(REGEX MATCH "CUDSS_LIBRARY_PATH=([^\n]*)" _ ${PYTHON_OUTPUTS})
set(ENV_CUDSS_PATH ${CMAKE_MATCH_1})
string(REGEX MATCH "CUBLAS_LIBRARY_PATH=([^\n]*)" _ ${PYTHON_OUTPUTS})
set(ENV_CUBLAS_PATH ${CMAKE_MATCH_1})

message(STATUS "Found Python CUDA libs at: ${ENV_NVIDIA_PATH}")
message(STATUS "Found libcudart.so at: ${ENV_CUDART_PATH}")
message(STATUS "Found libcudss.so at: ${ENV_CUDSS_PATH}")
message(STATUS "Found libcublas.so at: ${ENV_CUBLAS_PATH}")

# CUDART
add_library(cudart_from_python SHARED IMPORTED)
set_target_properties(cudart_from_python PROPERTIES
    IMPORTED_LOCATION "${ENV_CUDART_PATH}"
    INTERFACE_INCLUDE_DIRECTORIES "${ENV_NVIDIA_PATH}/nvidia/cuda_runtime/include"
)

# CUDSS
add_library(cudss_from_python SHARED IMPORTED)
set_target_properties(cudss_from_python PROPERTIES
    IMPORTED_LOCATION "${ENV_CUDSS_PATH}"
    INTERFACE_INCLUDE_DIRECTORIES "${ENV_NVIDIA_PATH}/nvidia/cu12/include"
)

# cuBLAS
add_library(cublas_from_python SHARED IMPORTED)
set_target_properties(cublas_from_python PROPERTIES
    IMPORTED_LOCATION "${ENV_CUBLAS_PATH}"
    INTERFACE_INCLUDE_DIRECTORIES "${ENV_NVIDIA_PATH}/nvidia/cublas/include"
)

# O3 optimization build
if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE Release CACHE STRING "Choose the type of build." FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
endif()

enable_language(CUDA)
endif() # SPINEAX_USE_CUDA

# cuDSS FFI files (CUDA backend)
if(SPINEAX_USE_CUDA)

# traditional batch
nanobind_add_module(batch_solve NOMINSIZE 
  src/spineax/cudss/batch_solve.cpp
)

# pseudo batch (enable features lacking in normal batch whilst also solving a batch)
# DISABLED: Requires CUDA kernel compilation which has version mismatch issues
# nanobind_add_module(pbatch_solve NOMINSIZE
#   src/spineax/cudss/pseudo_batch_solve.cu
# )

# single solve and Return Everything (return all data that cuDSS has)
nanobind_add_module(single_solve_re NOMINSIZE 
  src/spineax/cudss/single_solve_re.cpp
)

# traditional single solve
nanobind_add_module(single_solve NOMINSIZE
  src/spineax/cudss/single_solve.cpp
)

foreach(TARGET
  batch_solve
  single_solve
  single_solve_re
)
    target_include_directories(${TARGET} PRIVATE
        ${XLA_DIR}
        cudss_from_python
        cudart_from_python
        cublas_from_python
        "${ENV_NVIDIA_PATH}/nvidia/cuda_nvcc/include"
    )

    target_link_libraries(${TARGET} PRIVATE
        cudss_from_python
        cudart_from_python
        cublas_from_python
    )

    # Suppress warnings from XLA FFI headers that have control flow issues
    # These are in jaxlib's XLA headers, not in spineax code
    target_compile_options(${TARGET} PRIVATE
        $<$<COMPILE_LANGUAGE:CXX>:-Wno-return-type -Wno-attributes>
    )
    
    # Add RPATH so the .so can find its dependencies
    # Use $ORIGIN to make paths relative to the installed module location
    # Modules install to site-packages/spineax/, CUDA libs are in site-packages/nvidia/*/lib/
    set_target_properties(${TARGET} PROPERTIES
        BUILD_RPATH "${ENV_NVIDIA_PATH}/nvidia/cu12/lib:${ENV_NVIDIA_PATH}/nvidia/cublas/lib:${ENV_NVIDIA_PATH}/nvidia/cuda_runtime/lib"
        INSTALL_RPATH "$ORIGIN/../nvidia/cu12/lib:$ORIGIN/../nvidia/cublas/lib:$ORIGIN/../nvidia/cuda_runtime/lib"
        INSTALL_RPATH_USE_LINK_PATH FALSE
    )
endforeach()

# Note: pbatch_solve disabled due to CUDA kernel version mismatch
install(
  TARGETS
    batch_solve
    single_solve
    single_solve_re
  LIBRARY
  DESTINATION spineax
)
endif() # SPINEAX_USE_CUDA

#==============================================================================
# BaSpaCho backend (Metal/OpenCL/CPU)
#==============================================================================
if(SPINEAX_USE_BASPACHO)
  message(STATUS "Building BaSpaCho backend")

  # Find BaSpaCho
  if(BASPACHO_ROOT)
    set(BASPACHO_INCLUDE_DIR "${BASPACHO_ROOT}")
    set(BASPACHO_BUILD_DIR "${BASPACHO_ROOT}/build")
    set(EIGEN_INCLUDE_DIR "${BASPACHO_BUILD_DIR}/_deps/eigen-src")

    # Find baspacho library (static)
    find_library(BASPACHO_LIBRARY
      NAMES BaSpaCho BaSpaCho_static baspacho
      PATHS "${BASPACHO_BUILD_DIR}/baspacho/baspacho" "${BASPACHO_BUILD_DIR}/baspacho" "${BASPACHO_BUILD_DIR}"
      NO_DEFAULT_PATH
    )

    if(NOT BASPACHO_LIBRARY)
      message(FATAL_ERROR "Could not find baspacho library in ${BASPACHO_BUILD_DIR}")
    endif()

    message(STATUS "Found BaSpaCho: ${BASPACHO_LIBRARY}")
    message(STATUS "BaSpaCho include: ${BASPACHO_INCLUDE_DIR}")

    # Create imported target (static library)
    add_library(baspacho STATIC IMPORTED)
    set_target_properties(baspacho PROPERTIES
      IMPORTED_LOCATION "${BASPACHO_LIBRARY}"
      INTERFACE_INCLUDE_DIRECTORIES "${BASPACHO_INCLUDE_DIR}"
    )

    # BaSpaCho dependencies - find dispenso
    find_library(DISPENSO_LIBRARY
      NAMES dispenso
      PATHS "${BASPACHO_BUILD_DIR}/_deps/dispenso-build/dispenso"
      NO_DEFAULT_PATH
    )
    if(DISPENSO_LIBRARY)
      message(STATUS "Found dispenso: ${DISPENSO_LIBRARY}")
    endif()
  else()
    message(FATAL_ERROR "BASPACHO_ROOT must be set when SPINEAX_USE_BASPACHO=ON")
  endif()

  # BaSpaCho solve module
  nanobind_add_module(baspacho_solve NOMINSIZE
    src/spineax/cudss/baspacho_solve.cpp
  )

  target_include_directories(baspacho_solve PRIVATE
    ${XLA_DIR}
    ${BASPACHO_INCLUDE_DIR}
    ${EIGEN_INCLUDE_DIR}
  )

  # Check for Metal and BLAS support on Apple
  if(APPLE)
    find_library(METAL_FRAMEWORK Metal)
    find_library(FOUNDATION_FRAMEWORK Foundation)
    find_library(ACCELERATE_FRAMEWORK Accelerate)
  endif()

  target_link_libraries(baspacho_solve PRIVATE
    baspacho
  )

  # Add dispenso if found
  if(DISPENSO_LIBRARY)
    target_link_libraries(baspacho_solve PRIVATE ${DISPENSO_LIBRARY})
  endif()

  # Add BLAS/LAPACK (Accelerate on macOS)
  if(APPLE AND ACCELERATE_FRAMEWORK)
    target_link_libraries(baspacho_solve PRIVATE ${ACCELERATE_FRAMEWORK})
  endif()

  # Enable Metal backend on macOS
  if(APPLE AND METAL_FRAMEWORK)
    message(STATUS "Metal framework found - enabling Metal backend")
    target_compile_definitions(baspacho_solve PRIVATE BASPACHO_USE_METAL)
    target_link_libraries(baspacho_solve PRIVATE
      ${METAL_FRAMEWORK}
      ${FOUNDATION_FRAMEWORK}
    )
  endif()

  # Suppress XLA FFI header warnings
  target_compile_options(baspacho_solve PRIVATE
    $<$<COMPILE_LANGUAGE:CXX>:-Wno-return-type -Wno-attributes>
  )

  install(
    TARGETS baspacho_solve
    LIBRARY DESTINATION spineax
  )
endif() # SPINEAX_USE_BASPACHO